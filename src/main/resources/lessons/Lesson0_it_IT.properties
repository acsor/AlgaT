lesson.name = Algoritmo di Dijkstra
lesson.description = Algoritmo pubblicato nel 1959 per ottenere l'albero dei \
  cammini minimi in un grafo ciclico con pesi non negativi da un nodo radice. \
  Si basa sulla verifica delle condizioni di Bellman e una coda con priorità. \
  Nella sua versione originale, l'algoritmo trovava il cammino minimo tra due \
  nodi dati, e non utilizzava una coda con priorità.\n\n \
  Nella versione mostrata, si utilizzano tre vettori: T[u] contiene il padre di \
  u nell'albero dei cammini minimi, b[u] è true se u è in S, d[u] contiene \
  la distanza di u da r (il nodo radice).
# CSV field containing a hierarchical list of getTopics the lesson belongs to
lesson.topics = Grafi,Cammini minimi
lesson.view = unibo.algat.view.DijkstraLessonView
lesson.pseudoCode = \
  DijstraAlgorithm(Graph G, Node r, int[] T) \n \
    \tint[] d := new int[G.V().size()];\n \
    \tbool[] b := new bool[G.V().size()];\n \
    \tforeach u in G.V() - {r} do \n \
        \t\tT[u] := nil; \n \
        \t\td[u] := inf; \n \
        \t\tb[u] := false; \n \
    \tT[r] := nil; \n \
    \td[r] := 0; \n \
    \tb[r] := true; \n \
    \tPriorityQueue S := new PriorityQueue(); \n \
    \tS.insert(r);\n \
    \twhile not S.isEmpty() do \n \
        \t\tNode u := S.deleteMin(); \n \
        \t\tb[u] := false; \n \
        \t\tforeach v in G.adj(u) do \n \
            \t\t\tif d[u] + w(u,v) < d[v] then \n \
                \t\t\t\t if not b[v] then \n \
                    \t\t\t\t\tS.insert(v); \n \
                    \t\t\t\t\tb[v] := true; \n \
                \t\t\t\telse \n \
                    \t\t\t\t\tS.decrease(v, d[u] + w(u,v)); \n \
                \t\t\t\tT[v] := u; \n \
                \t\t\t\td[v] := d[u] + w(u,v); \n 
